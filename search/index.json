[{"content":"0xGame RE WP Week1 BabyBase 查壳无壳ida打开，进入主函数 发现有个encode函数，跟进 发现是普通的base64加密，拿到密文之后用cyber解一下即可 0xGame{N0w_y0u_kn0w_B4se64_Enc0d1ng_w3ll!}\nBinaryMaster 查壳发现无壳，ida打开，打开之后F5反编译就看到flag了 0xGame{114514cc-a3a7-4e36-8db1-5f224b776271}\nSignSign 无壳拖进ida 发现这一段很像flag，尝试找找有没有前面部分的，shift+F12查看字符串找到前面部分 0xGame{S1gn1n_h3r3_4nd_b3g1n_Reversing_n0w} Xor-Beginning 无壳放进ida，查看主函数 发现一处异或 解密脚本如下 1 2 3 4 5 6 7 8 9 10 11 a = [ 126, 53, 11, 42, 39, 44, 51, 31, 118, 55, 27, 114, 49, 30, 54, 12, 76, 68, 99, 114, 87, 73, 8, 69, 66, 1, 90, 4, 19, 76, 0, 0, 0, 21, 100] b = \u0026#39;\u0026#39; for i in range(len(a)): a[i] = a[i] ^ (78 - i) b += chr(a[i]) print(b) 0xGame{X0r_1s_v3ry_Imp0rt4n7!}\nXor-Endian 无壳放进ida 有个encrypt函数，跟进 是一个与key的异或，key在主函数是Key0xGame2024 解密脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def decrypt(encrypted, key, length, key_length): decrypted = bytearray(encrypted) for i in range(length): decrypted[i] ^= key[i % key_length] return decrypted v6 = [1363025275, 253370901, 1448151638, 1415391232, 91507463, 139743552, 1450318164, 1985283101, 1465125718, 1934953223, 84430593, 0] key = b\u0026#34;Key0xGame2024\u0026#34; key_length = len(key) length = 44 encrypted = bytearray() for value in v6: encrypted.extend(value.to_bytes(4, byteorder=\u0026#39;little\u0026#39;)) decrypted = decrypt(encrypted, key, length, key_length) print(decrypted.decode(\u0026#39;utf-8\u0026#39;)) Week2 BabyUPX 查壳，发现是最简单的UPX壳，放进脱壳软件里面脱壳，拖进ida 跟进encode函数 发现是位运算，下面填脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 enc = [3, 135, 116, 22, 214, 86, 183, 99, 131, 70, 102, 102, 67, 83, 131, 210, 35, 147, 86, 83, 210, 67, 54, 54, 3, 210, 22, 147, 54, 38, 210, 147, 115, 19, 102, 86, 54, 51, 51, 131, 86, 35, 102, 215] flag = \u0026#39;\u0026#39; for i in range(44): #提取高4位并右移，提取低4位并左移 original = int((enc[i] \u0026amp; 0xF0) / 16) | (enc[i] \u0026amp; 0x0F) \u0026lt;\u0026lt; 4 flag += chr(original) print(flag) #0xGame{68dff458-29e5-4cc0-a9cb-971fec338e2f} (官方wp给出)可以看出每个字节高4位和低4位交换，实际上就是16进制逆序。 FirstSight-Jar jadx打开，主要逻辑红框框住，接下来直接上脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def dec(enc): Alphabat = \u0026#34;0123456789abcdef\u0026#34; reverse_map = {} for i in range(len(Alphabat)): new_index = ((i * 5) + 3) % 16 reverse_map[Alphabat[new_index]] = Alphabat[i] dec_str = [] for char in enc: if char in reverse_map: dec_str.append(reverse_map[char]) else: dec_str.append(char) return \u0026#39;\u0026#39;.join(dec_str) enc = \u0026#34;ab50e920-4a97-70d1-b646-cdac5c873376\u0026#34; flag = dec(enc) print(\u0026#34;0xGame{\u0026#34;+ flag + \u0026#34;}\u0026#34;) #0xGame{b8a9fe39-dbe4-4926-87d7-52b5a5140047} FisrtSight-Pyc 看到pyc文件，uncompyle6反编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import hashlib user_input = input(\u0026#34;请输入神秘代号：\u0026#34;) if user_input != \u0026#34;Ciallo~\u0026#34;: print(\u0026#34;代号不是这个哦\u0026#34;) exit() input_hash = hashlib.md5(user_input.encode()).hexdigest() input_hash = list(input_hash) for i in range(len(input_hash)): if ord(input_hash[i]) in range(48, 58): original_num = int(input_hash[i]) new_num = (original_num + 5) % 10 input_hash[i] = str(new_num) input_hash = \u0026#34;\u0026#34;.join(input_hash) print(\u0026#34;0xGame{{{}}}\u0026#34;.format(input_hash)) 直接运行一遍，就发现flag出来了0xGame{2f5ef5762bf8a2c043d836b522127e54}\nXor::Ramdom 无壳，拖进ida里面，跟进主函数，下图是主要的判断，这题是一道Windows下的伪随机数，记住运行环境不一样随机数生成也会不一样 我们通过分析可以知道其实这两个随机数种子只会运行0x77这一个，因为v6的判断只判断了长度，flag肯定满足长度，下面是一个奇偶性的判断 我们直接写出脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main() { unsigned char ra, key; unsigned char* enc; unsigned long long v13[4]; v13[0] = 0x1221164E1F104F0C; v13[1] = 0x171F240A4B10244B; v13[2] = 0x1A2C5C2108074F09; v13[3] = 99338668810000; srand(0x77); rand(); ra = rand(); enc = (unsigned char*)v13; for (int i = 0; i \u0026lt;= 29; i++){ if (i \u0026amp; 1 != 0) { key = ra; } else key = ra + 3; enc[i] ^= key; } printf(\u0026#34;0xGame{%s}\u0026#34;, enc); return 0; } //0xGame{r4nd0m_i5_n0t_alw4ys_\u0026#39;Random\u0026#39;!} ZzZ 跟进到主函数 题目给出了字符串的形式0xGame{%8llx-%4s-%4s-%4s-%12llx}\n%8x 表示一个以十六进制格式输出的整数，宽度为 8。\n%4s 表示一个宽度为 4 的字符串。\n%12x 表示一个以十六进制格式输出的整数，宽度为 12。\n我们还发现框住的if语句有多个条件判断，这时我们可以想到z3求解，直接上z3库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from z3 import * flag = [] v13 = 0xE544267D v14 = 0xD085A85201A4 v10,v11,v12 = BitVecs(\u0026#34;v10 v11 v12\u0026#34;,32) s = Solver() s.add(11 * v11 + 14 * v10 - v12 == 0x48FB41DDD) s.add(9 * v10 - 3 * v11 + 4 * v12 == 0x2BA692AD7) s.add(((v12 - v11) \u0026gt;\u0026gt; 1) + (v10 ^ 0x87654321) == 3451779756) if s.check()==sat: tmp = s.model() for i in (v10, v11, v12): l = tmp[i].as_long() b = l.to_bytes(4, \u0026#34;little\u0026#34;) flag = b.decode() print(flag) #0xGame{e544267d-7812-44b3-a35d-d085a85201a4} ","date":"2024-10-11T18:46:04+08:00","permalink":"https://mkkkk-create.github.io/2024/0xgame/","title":"0xgame"},{"content":"复现了一下久远的比赛哈哈哈\neasypyc 题目直接给了pyc文件，我们直接uncompyle6反编译 可以看到图片中显示反汇编失败原因，我们知道这是python的字节码，我们用pycdas看一下字节码 找到了报错的原因，接下来我们打开python的opcode查看到这个指令的代码是113，转成十六进制就是0x71,我们打开010editor搜索71 04 71 06 71 02 然后删除掉这一段紫色的花指令，当然还没结束，因为co_code中有一个ob_size 成员里面保存了co_code的长度，如果co_code的实际长度与ob_size里记录的长度不匹配的话反编译时依然会报错。接下来就是找到ob_size所在的位置将其进行修改，在python3.8版本里ob_size会以s 或 t 的类型标志开始接下来的几个字节会是一个整数，代表co_code的长度。本题的长度就是上图红框框住的地方，减去6个花指令字节改成62就可以反编译了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import base64, sys def check(ininput): str1 = \u0026#34;RitdR+kuGPFoYpX4NVP{PVOx[VSzXhLnO{L2Xkj3[l[8\u0026#34; str2 = list(str1) list1 = list(ininput) for q in range(len(str2)): if list1[q] != str2[q]: print(\u0026#34;Wrong!!!\u0026#34;) return return None else: print(\u0026#34;All input is correct!\u0026#34;) def encode(eenv): env = base64.b64encode(eenv.encode(\u0026#34;utf-8\u0026#34;)).decode(\u0026#34;utf-8\u0026#34;) str2 = list(env) for i in range(len(str2)): str2[i] = ord(str2[i]) ^ 2 else: for j in range(11): str2[j] -= 6 else: for k in range(11, 22): str2[k] += 1 else: for h in range(22, 33): str2[h] = str2[h] else: for l in range(33, 44): str2[l] ^= 3 else: for w in range(len(str2)): str2[w] = chr(str2[w]) else: str3 = \u0026#34;\u0026#34; for n in range(len(str2)): str3 += str2[n] else: return str3 enc = input(\u0026#34;Please input your flag:\u0026#34;) ininput = list(enc) if len(ininput) != 33: print(\u0026#34;Wrong length!\u0026#34;) sys.exit() else: env = encode(enc) check(env) 接下来放脚本，一步一步来即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import base64 str1 = \u0026#34;RitdR+kuGPFoYpX4NVP{PVOx[VSzXhLnO{L2Xkj3[l[8\u0026#34; str2 = list(str1) for i in range(len(str2)): str2[i] = ord(str2[i]) for j in range(11): str2[j] += 6 for k in range(11,22): str2[k] -= 1 for h in range(22,33): str2[h] = str2[h] for l in range(33,44): str2[l] ^= 3 for w in range(len(str2)): str2[w] = chr(str2[w]) for m in range(len(str2)): str2[m] = ord(str2[m]) ^ 2 str3 = \u0026#39;\u0026#39; for n in range(len(str2)): str3 += chr(str2[n]) str4 = \u0026#39;\u0026#39; str4 = base64.b64decode(str3).decode(\u0026#39;utf-8\u0026#39;) print(str4) babyrust ","date":"2024-09-22T19:20:28+08:00","permalink":"https://mkkkk-create.github.io/2024/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E9%BB%84%E6%B2%B3%E6%B5%81%E5%9F%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B/","title":"第二届黄河流域网络安全技能挑战赛"},{"content":" 本篇博客以BaseCTF的UPX压缩壳的题目为基础进行讲解 什么是压缩壳 加壳：其实是利用特殊的算法，对EXE、DLL文件里的资源进行压缩。类似WINZIP 的效果，只不过这个压缩之后的文件，可以独立运行，解压过程完全隐蔽，都在内存中完成。解压原理，是加壳工具在文件头里加了一段指令，告诉CPU，怎么才能解压自己。当加壳时，其实就是给可执行的文件加上个外衣。用户执行的只是这个外壳程序。当执行这个程序的时候这个壳就会把原来的程序在内存中解开，解开后，以后的就交给真正的程序。\u0026mdash;-摘自百度百科\nEasy UPXmini 拿到题目查壳 可以看到写明了被UPX壳加密过了，但是这种题通常是出题者为了让大家认识工具出的，所以我们可以直接工具脱壳 这就是脱完壳的结果，后面就是ida分析，这里就不细说了\nNormal UPX 查壳 我们发现这个UPX壳不能直接工具脱壳，对比上一个Easy关卡我们发现红框框住的地方不太一样\n这时候我们就引入一个名词：区段名，Normal关卡中正是修改了UPX壳的区段名导致不能直接工具脱壳\n接下来我们打开010editor来恢复区段名 恢复区段名后我们就可以工具脱壳了\nNormal UPX PRO 查壳发现不能直接工具脱壳 发现区段名也消失了，试过改区段名发现没用，还是不能脱壳 引入一个新的名词：overlay_offset\n这里overlay_offset值为p_info字段的文件偏移 正确的是F4 00 00 00，改了之后，就可以正常脱壳了\n手动脱壳 UPX PRO MAX 查壳 我们可以看到入口区段什么都没显示，只有提示被upx壳保护，打开010editor发现区段名都变成了00\n这个时候我们就搬出更高级的脱壳手法，手动脱壳，本题主要靠ESP定律脱壳(也就是靠堆栈平衡找到OEP入口点)\n以下是脱壳步骤，首先我们拖入x64dbg中，按下F9运行 我们看到这里有多个push，我们前面提到ESP就是堆栈平衡，所以我们接下来找到pop就可以找到OEP入口了\n对RSP寄存器按下右键 点击在内存窗口中转到 这里也可以选二字节，字节，看框选多少数据\r接着按几次F9运行下一断点，可以看到 上面红色方框中的多个pop就说明解压已经结束，正要进入主要函数，下面红色方框中就是OEP了，然后我们只需F8通过jmp跳到正确有效函数的入口 跳转到这，我们就可以使用插件 scylla 进行脱壳了 可以看到进程已经填好，OEP也填好了，我们只要点击Dump，然后保存好文件\n再点击IAT Autosearch\nIAT已找到，再点击Get Imports\n最后点击Fix Dump，选择我们刚才Dump下来的文件就可以了。最后分析的时候我们分析的是修复好的文件，UPX PRO MAX_dump_SCY.exe\n","date":"2024-09-20T11:17:49+08:00","permalink":"https://mkkkk-create.github.io/2024/%E4%BB%8E%E5%B7%A5%E5%85%B7%E5%88%B0%E6%89%8B%E5%8A%A8%E5%AD%A6%E4%BC%9Aupx%E8%84%B1%E5%A3%B3/","title":"从工具到手动学会UPX脱壳"},{"content":"编码原理 Base64编码是将字符串以每3个8比特(bit)的字节子序列拆分成4个6比特(bit)的字节(6比特有效字节，其实也是8比特的字节，只是最左边两个比特永远为0)子序列，再将得到的子序列查找Base64的编码索引表，得到对应的字符拼接成新的字符串的一种编码方式。\n举例 图摘自知乎\r（1）.先将原文转为ASCII码\n（2）.将ASCII码转为二进制数\n（3）.将二进制数合并，每八个二进制位为一组，将每一组按照索引表对应相应的base64码\n注：如果编码内容字节数不是3的整数倍！！！ 1.如果最后剩下1个字节，那么将补 4个 0 位，编码成 2个 Base64 字符，然后补两个\u0026quot;=\u0026quot; 图摘自知乎\r2.如果最后剩下 2 个字节，那么将补 2 个 0 位，编码成 3 个 Base64 字符，然后补一个\u0026quot;=\u0026quot; 图摘自知乎\r在知道了加密原理之后我们就可以逆向解密\n先找出编码后的字符在编码之前代表的数字\n编码中将3位个字符变成4个字符，得到这4个字符的每个字符代表的原本数字\n因为在编码中间每个字符用base64码表进行了替换，所以这里要先换回来\n在对换回来的数字进行位运算使其还原成3个字符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // Base64字符表 static const char base64_chars[] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; // 将Base64字符转换为其对应的整数值 int base64_value(char c) { int i; for (i = 0; i \u0026lt; 64; i++) { if (base64_chars[i] == c) { return i; } } return -1; } // 将Base64字符串解码为原始数据 void base64_decode(const char *input, unsigned char *output, int output_size) { int input_size = strlen(input); int i, j, k; unsigned char temp[4]; for (i = 0, j = 0; i \u0026lt; input_size; i += 4) { for (k = 0; k \u0026lt; 4; k++) { temp[k] = base64_value(input[i + k]); } output[j++] = (temp[0] \u0026lt;\u0026lt; 2) | (temp[1] \u0026gt;\u0026gt; 4); if (k \u0026gt;= 2) { //temp[1] \u0026amp; 0x0F作用是取最低四个比特位 output[j++] = ((temp[1] \u0026amp; 0x0F) \u0026lt;\u0026lt; 4) | (temp[2] \u0026gt;\u0026gt; 2); } if (k \u0026gt;= 3) { //temp[2] \u0026amp; 0x03作用是取最低四个比特位 output[j++] = ((temp[2] \u0026amp; 0x03) \u0026lt;\u0026lt; 6) | temp[3]; } } output[j] = \u0026#39;\\0\u0026#39;; } int main() { const char *input = \u0026#34;SGVsbG8sIFdvcmxkIQ==\u0026#34;; // \u0026#34;Hello, World!\u0026#34;的Base64编码 unsigned char output[strlen(input)]; base64_encode() base64_decode(input, output, sizeof(output)); printf(\u0026#34;Decoded string: %s\u0026#34;, output); return 0; } ","date":"2024-09-18T00:57:35+08:00","permalink":"https://mkkkk-create.github.io/2024/base64%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/","title":"Base64算法详解"},{"content":"2024WMCTF Re复现 Rustdriod 发现是apk文件，拖入jadx查看 发现加载wmcheck的包，apktool解包打开so文件，定位到check函数 我们发现这是类似于rc4的初始化 之后再次看到函数里面有名称为rc4的函数名，我们就可以确定了，但是这个rc4是魔改的！！！ 通过其他师傅的wp(https://blog.wm-team.cn/index.php/archives/80/)得知是单字节加密，下面是解题脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def KSA(key): S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] return S def PRGA(S): i, j = 0, 0 while True: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] K = S[(S[i] + S[j]) % 256] yield K def RC4(key, text): S = KSA(key) keystream = PRGA(S) res = [] for char in text: res.append(char ^ next(keystream)) return bytes(res) s1=[ 0x77, 0x88, 0x99, 0x66] s2=[0x4E4FCE594215BA1F,0xC745BAE69BFD994,0x87081E9C7F8AFCC0,0x2BB08F87F5646BF5,0x29FF53E2] key=b\u0026#39;fun@eZ\u0026#39; s3=b\u0026#39;\u0026#39;.join(num.to_bytes((num.bit_length()+7)//8, byteorder=\u0026#39;little\u0026#39;) for num in s2) s5=RC4(key,s3) s4=[0]*128 for i in range(len(s5)): s4[i]=s5[i] for i in range(len(s5)): s4[i] ^= s1[i\u0026amp;3] s4[i] = ((s4[i] \u0026lt;\u0026lt; 5) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 3) \u0026amp; 0xff) s4[i] ^= 0xde s4[i] = ((s4[i] \u0026lt;\u0026lt; 4) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 4) \u0026amp; 0xff) s4[i] ^= 0xad s4[i] = ((s4[i] \u0026lt;\u0026lt; 3) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 5) \u0026amp; 0xff) s4[i] ^= 0xbe s4[i] = ((s4[i] \u0026lt;\u0026lt; 2) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 6) \u0026amp; 0xff) s4[i] ^= 0xef s4[i] = ((s4[i] \u0026lt;\u0026lt; 1) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 7) \u0026amp; 0xff) print(chr(s4[i]),end=\u0026#39;\u0026#39;) 得到flag WMCTF{2a04aed7-e736-43c4-80a7-f6ed28de34eb}\nez_learn 无壳，拖进ida，反编译之后奇奇怪怪 下个断点调试一下，发现调试就闪退，往下翻看到了TLS反调试函数 nop掉反调试函数，之后发现了一处引起堆栈不平衡的花指令 nop掉重新编译一下就可以进入主函数了 发现有两个flag wrong，猜测flag应该分成两部分加密 之后发现还有一个加密函数跟进，发现是SM4加密 这是S盒 对比普通的SM4加密，我们发现有魔改，一处异或0x34，一处0x12 下面是脚本，基于普通SM4(https://blog.csdn.net/twq1689739507/article/details/122118411)修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 #include\u0026lt;stdio.h\u0026gt; #define u8 unsigned char #define u32 unsigned long // S盒 const u8 Sbox[256] = { 0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05, 0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99, 0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62, 0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6, 0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8, 0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35, 0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87, 0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e, 0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1, 0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3, 0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f, 0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51, 0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8, 0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0, 0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84, 0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48 }; // 密钥扩展算法的常数FK const u32 FK[4] = { 0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc }; // 密钥扩展算法的固定参数CK const u32 CK[32] = { 0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279 }; u32 functionB(u32 b); // 查S盒的函数B u32 loopLeft(u32 a, short length); // 循环左移函数 u32 functionL1(u32 a); // 线性变换L u32 functionL2(u32 a); // 线性变换L\u0026#39; u32 functionT(u32 a, short mode); // 合成变换T void extendFirst(u32 MK[], u32 K[]); // 密钥扩展算法第一步 void extendSecond(u32 RK[], u32 K[]); // 密钥扩展算法第二步 void getRK(u32 MK[], u32 K[], u32 RK[]); // 轮密钥获取算法 void iterate32(u32 X[], u32 RK[]); // 迭代算法 void reverse(u32 X[], u32 Y[]); // 反转函数 void encryptSM4(u32 X[], u32 RK[], u32 Y[]); // 加密算法 void decryptSM4(u32 X[], u32 RK[], u32 Y[]); // 解密算法 /* 查S盒的函数B 参数: u32 b 返回值: 查S盒的结果u32 b */ u32 functionB(u32 b) { u8 a[4]; short i; a[0] = b / 0x1000000; a[1] = b / 0x10000; a[2] = b / 0x100; a[3] = b; b = Sbox[a[0]] * 0x1000000 + Sbox[a[1]] * 0x10000 + Sbox[a[2]] * 0x100 + Sbox[a[3]]; return b; } /* 循环左移算法 参数： u32 a length：循环左移位数 返回值：u32 b */ u32 loopLeft(u32 a, short length) { short i; for (i = 0; i \u0026lt; length; i++) { a = a * 2 + a / 0x80000000; } return a; } /* 密钥线性变换函数L 参数： u32 a 返回值：线性变换后的u32 a */ u32 functionL1(u32 a) { return a ^ loopLeft(a, 2) ^ loopLeft(a, 10) ^ loopLeft(a, 18) ^ loopLeft(a, 24); } /* 密钥线性变换函数L\u0026#39; 参数： u32 a 返回值：移位操作后的u32 a */ u32 functionL2(u32 a) { return a ^ loopLeft(a, 13) ^ loopLeft(a, 23); } /* 合成变换T 参数： u32 a short mode：1表示明文的T，调用L；2表示密钥的T，调用L\u0026#39; 返回值：合成变换后的u32 a */ u32 functionT(u32 a, short mode) { return mode == 1 ? functionL1(functionB(a)) : functionL2(functionB(a)); } /* 密钥扩展算法第一步 参数： MK[4]：密钥 K[4]:中间数据，保存结果 （FK[4]：常数） 返回值：无 */ void extendFirst(u32 MK[], u32 K[]) { int i; for (i = 0; i \u0026lt; 4; i++) { K[i] = MK[i] ^ FK[i]^0x34343434; } } void extendThird(u32 MK[], u32 K[]) { int i; for (i = 0; i \u0026lt; 1; i++) { K[i+1] = MK[i] ^ K[i] ^ 0x34343434; } } /* 密钥扩展算法第二步 参数： RK[32]：轮密钥，保存结果 K[4]：中间数据 （CK[32]：固定参数） 返回值：无 */ void extendSecond(u32 RK[], u32 K[]) { short i; for (i = 0; i \u0026lt; 32; i++) { K[(i + 4) % 4] = 0x34343434^K[i % 4] ^ functionT(K[(i + 1) % 4] ^ K[(i + 2) % 4] ^ K[(i + 3) % 4] ^ CK[i]^0x12121212, 2); RK[i] = K[(i + 4) % 4]; } } /* 密钥扩展算法 参数： MK[4]：密钥 K[4]：中间数据 RK[32]：轮密钥，保存结果 返回值：无 */ void getRK(u32 MK[], u32 K[], u32 RK[]) { extendFirst(MK, K); extendSecond(RK, K); //extendThird(MK,K); } /* 迭代32次 参数： u32 X[4]：迭代对象，保存结果 u32 RK[32]：轮密钥 返回值：无 */ void iterate32(u32 X[], u32 RK[]) { short i; for (i = 0; i \u0026lt; 32; i++) { X[(i + 4) % 4] = X[i % 4] ^0x34343434^ functionT(X[(i + 1) % 4] ^ X[(i + 2) % 4] ^ X[(i + 3) % 4] ^ RK[i]^0x12121212, 1); } } /* 反转函数 参数； u32 X[4]：反转对象 u32 Y[4]：反转结果 返回值：无 */ void reverse(u32 X[], u32 Y[]) { short i; for (i = 0; i \u0026lt; 4; i++) { Y[i] = X[4 - 1 - i]; } } /* 加密算法 参数： u32 X[4]：明文 u32 RK[32]：轮密钥 u32 Y[4]：密文，保存结果 返回值：无 */ void encryptSM4(u32 X[], u32 RK[], u32 Y[]) { iterate32(X, RK); reverse(X, Y); } /* 解密算法 参数： u32 X[4]：密文 u32 RK[32]：轮密钥 u32 Y[4]：明文，保存结果 返回值：无 */ void decryptSM4(u32 X[], u32 RK[], u32 Y[]) { short i; u32 reverseRK[32]; for (i = 0; i \u0026lt; 32; i++) { reverseRK[i] = RK[32 - 1 - i]; } iterate32(X, reverseRK); reverse(X, Y); } int main(void) { u32 X[4]; // 明文 u32 MK[4] = { 0x22313 ,0x821DEF ,0x123128 ,0x43434310 }; // 密钥 u32 RK[32]; // 轮密钥 u32 K[4]; // 中间数据 u32 Y[4] = { 0xC676E86F, 0xAD67E8F8, 0xCA9DB9AC, 0xB1AE068E }; // 密文 //u32 Y[4] = { 0xD51B0298, 0xD827C6D3, 0x31A5A335, 0x893A7A66 }; short i; // 临时变量 decryptSM4(Y, RK, X); printf(\u0026#34;%08x %08x %08x %08x\\n\u0026#34;, X[0], X[1], X[2], X[3]); return 0; } flag：WMCTF{CRC32andAnti_IS_SO_EASY!!}\nre1 拖入jadx查看主函数，发现加载Encrypt的so文件中的checkyourflag函数，解包apk，so拖入ida 下断点调试不了，后面看官方wp才知道是因为动态注册的原因 JNI注册方法分为静态注册和动态注册，静态注册的方法可以在IDA的函数窗口或者导出表中直接找到，比较简单。动态注册的方法需要分析JNI_OnLoad函数 从图片可以得知题目使用bytehook直接把几个函数hook了 接下来回到真正的check函数处，看到了被hook的函数，接下来就可以下断点慢慢调试了 经过分析，我们可以知道这是一个普通的xtea+魔改，异或了0x5A 下面是脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from ctypes import * def decrypt(v, key): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) delta = 0x5EEFEF3 total = c_uint32(0 - (delta * 66)) for i in range(66): v1.value -= (((v0.value \u0026lt;\u0026lt; 6) ^ (v0.value \u0026gt;\u0026gt; 6)) + v0.value) ^ (total.value + key[((total.value \u0026amp; 0xff) \u0026gt;\u0026gt; 6)]) total.value += delta v0.value -= (((v1.value \u0026lt;\u0026lt; 6) ^ (v1.value \u0026gt;\u0026gt; 6)) + v1.value) ^ (total.value + key[total.value \u0026amp; 3]) return v0.value, v1.value def xtea(inp: bytes, key: bytes): from struct import pack, unpack k = unpack(\u0026#34;\u0026lt;4I\u0026#34;, key) inp_len = len(inp) // 4 value = unpack(f\u0026#34;\u0026lt;{inp_len}I\u0026#34;, inp) res = b\u0026#34;\u0026#34; for i in range(0, inp_len, 2): v = [value[i], value[i + 1]] # x = encrypt(v,k) x = decrypt(v, k) res += pack(\u0026#34;\u0026lt;2I\u0026#34;, *x) return res cip = bytes([0xD2, 0x5F, 0xC0, 0xEF, 0x5E, 0x62, 0x78, 0x93, 0xA0, 0x41, 0x1F, 0x84, 0x4A, 0x5F, 0xD0, 0x06, 0x9A, 0x8F, 0x89, 0xDC, 0xFC, 0x7C, 0xAA, 0x21, 0x0B, 0xFB, 0x29, 0x42, 0x8B, 0x2B, 0xE5, 0x31]) key = bytes([0xFF, 0xFF, 0xFF, 0xFF, 0xAA, 0xAA, 0xAA, 0xAA, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11]) ret = xtea(cip, key) ret = bytearray(ret) for i in range(len(ret)): ret[i] ^= i ^ 0x5a print(bytes(ret)) ","date":"2024-09-11T07:37:15+08:00","permalink":"https://mkkkk-create.github.io/2024/wmctf/","title":"WMCTF"}]
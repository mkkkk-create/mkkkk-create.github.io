[{"content":"BF 算法 (暴力匹配算法) 算法描述 注：模式匹配不一定是从主串的第一个位置开始，可以指定主串中开始查找的起始位置 pos。 分别利用 i 和 j 指针表示主串和模式 T, 逐个字符比对，不匹配就回溯 i-j+2 为什么是 i-j+2？ 因为元素是从下标 1 开始存储，为了不重复遍历，故 + 2，而不是 + 1\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int INDEX_BF(string s, string t, int pos){ i = pos; j = 1; while (i \u0026lt;= s.length() \u0026amp;\u0026amp; j \u0026lt;= t.length()){ if (s[i] == t[j]){ i++; j++; } else{ i = i - j + 2; j = 1; } } if (j \u0026gt; t.length()) return i - t.length(); else return 0; } 时间复杂度 设主串长度为 n，子串长度为 n 最好的情况 比较 m 次就可以，所以最好的情况是 O(m) 最坏的情况 每次都要比较到子串的最后一个字符 1 才发现匹配不成功，到最后（即主串中的后 m 位，即后 4 位）才匹配成功，主串中前面的字符（n-m 个字符）都要一一和子串进行 m(4)次匹配，然后发现匹配不成功，所以就是 (n-m)*m, 再去加上最后 m(4) 个字符进行 m(4)次匹配才发现匹配成功，所以就是(n-m)*m+m，即(n-m+1)m。所以最坏情况是 O(mn) 平均情况计算完就是 O(m*n) KMP 算法 算法描述 在得知了子串中有相等的前后缀之后，匹配失败时子串指针不需要回退到开头处，而是回退到相等前缀的后一个位置。\nKMP 算法要用到前缀表，我们来学习一下前缀表 设字符串 T=“aabaaf”，我们求一下 T 的前缀表 (用一个数组名为 next 的数组表示)。\n第一个子串是 t0=“a”，易知该子串没有前缀也没有后缀，故 next[0]=0 第二个子串是 t1=“aa”，该子串的前缀为 \u0026ldquo;a\u0026rdquo;，后缀也为 \u0026ldquo;a\u0026rdquo;，故 next[1]=1 第三个子串是 t2=“aab”，该子串的后缀中一定会有 \u0026ldquo;b\u0026rdquo;，前缀中一定不含有 \u0026ldquo;b\u0026rdquo;，则其没有相等的前后缀，故 next[2]=0 第四个子串是 t3=“aaba”，该子串的最大相等前后缀为 \u0026ldquo;a\u0026rdquo;，长度为 1，故 next[3]=1 第五个子串是 t4=“aabaa”，该子串的最大相等前后缀为 \u0026ldquo;aa\u0026rdquo;，长度为 2，故 next[4]=2 第六个子串是 t5=“aabaaf”，该子串的后缀中一定会有 \u0026ldquo;f\u0026rdquo;，前缀中一定不含有 \u0026ldquo;f\u0026rdquo;，则其没有相等的前后缀，故 next[5]=0 所以前缀表是用来回退的，它记录了模式串与主串 (文本串) 不匹配的时候，模式串应该从哪里开始重新匹配。 了解了前缀表的作用之后我们就可以知道 KMP 算法分为两步 计算前缀表 根据前缀表移动 i 和 j 两个指针进行匹配 代码实现 计算 next 前缀表 1 2 3 4 5 6 7 8 9 10 void get_next(string s, int next[]){ int j = 0; next[0] = 0; for (int i = 1; i \u0026lt;= s.size(); i++){ while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) j = next[j - 1];//前后缀不相同，去找j前一位的最长相等前后缀 if (s[i] == s[j]) j++; next[i] = j; } } 匹配查找 1 2 3 4 5 6 7 8 9 10 11 12 13 int cmp(string s, string t){ if (t.size() == 0) return 0; get_next(t,next); int j = 0; for (int i = 0; i \u0026lt;= s.size(); i++){ while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) j = next[j - 1]; if (s[i] == s[j]) j++; if (j == t.size()) return i - t.size() + 1; } return 0; } ","date":"2024-11-25T23:42:32+08:00","permalink":"https://mkkkk-create.github.io/2024/bf-%E7%AE%97%E6%B3%95%E4%B8%8E-kmp-%E7%AE%97%E6%B3%95/","title":"BF 算法与 KMP 算法"},{"content":"单链表定义 单链表通过一组任意的存储单元来存储线性表中的数据元素，不需要使用地址连续的存储单元，因此它不要求在逻辑上相邻的两个元素在物理位置上也相邻。\n单链表特点 用一组任意的存储单元存储线性表的数据元素，逻辑上两个相邻元素物理不一定相邻，因此不需要连续的存储空间 单链表是非随机的储存结构，因此要查找某个特定的节点要从表头开始遍历 每个链表节点既要存放元素自身的信息，又要存放一个后继的指针 1 2 3 4 typedef struct LNode{ ElemType data; //节点数据域 struct LNode *next; //节点指针域 }LNode, *LinkList; //LinkList为指向结构体的LNode的指针类型 对于首元节点、头节点、头指针的区分\n首元节点指的是链表中第一个元素的 头节点是首元节点之前附设的一个节点，如果是整形的话，头节点数据可以存放该线性表的长度， 也可以不存储信息 单链表基本操作的实现 初始化，构建空表 1 2 3 4 5 struct InitList(LinkList \u0026amp;L){ L = new LNode; //生成新节点作为头节点，头指针L指向头节点 L -\u0026gt; next = NULL; //头节点指针域置空 return OK; } 创建单链表 前插法 前面我们的初始化操作只是创建了一个只有头节点的空链表，这里我们补充如何创建带有多个节点的单链表 前插法是通过将新节点逐个插入链表头节点之后来创建单链表 输入顺序和单链表中的逻辑顺序是相反的 1 2 3 4 5 6 7 8 9 10 void CreateList_H(LinkList \u0026amp;L, int n){ L = new LNode; L -\u0026gt; next = NULL; //建立带头节点的空链表 for (int i = 0; i \u0026lt; n; i++){ p = new LNode; //生成新节点*p cin \u0026gt;\u0026gt; p -\u0026gt; data; //输入元素值赋给新节点*p的数据域 p -\u0026gt; next = L -\u0026gt; next; //新节点插入到头节点之后 L -\u0026gt; next = p; } } 后插法 将新节点插入到链表尾部来创建链表\n1 2 3 4 5 6 7 8 9 10 11 12 void CreateList_R(LinkList \u0026amp;L, int n){ L = new LNode; L -\u0026gt; next =NULL; r = L; //尾指针r指向头节点 for (int i = 0; i \u0026lt; n; i++){ p = new LNode; cin \u0026gt;\u0026gt; p -\u0026gt; data; p -\u0026gt; next = NULL; //新节点*p插入尾节点*r之后 r -\u0026gt; next = p; r = p; //r指向新的尾节点*p } } 取值 前面特点有提及，这里重温一下，链表中逻辑相邻的节点并没有存储在物理相邻的节点，所以我们要从链表的头节点开始遍历\n1 2 3 4 5 6 7 8 9 10 11 12 Status GetElem(LinkList L, int i, ElemType \u0026amp;e){ //在带头节点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值 p = L -\u0026gt; next; int j = 1; while (p \u0026amp;\u0026amp; j \u0026lt; i){ p = p -\u0026gt; next; j++; } if (!p || j \u0026gt; i) return ERROR; e = p -\u0026gt; data; return OK; } 查找 按值查找 顾名思义，根据给出的值查找，记住从头节点开始遍历即可\n1 2 3 4 5 6 7 LNode *LocateElem(LinkList L, ElemType e){ //在带头节点的单链表中查找值为e的元素 p = L -\u0026gt; next; //初始化 while (p \u0026amp;\u0026amp; p -\u0026gt; data != e) //顺着链表往后查找 p = p -\u0026gt; next; return p; } 插入 在两个数据元素 a 和 b 之前插入一个数据元素 x\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Status ListInsert(LinkList \u0026amp;L, int i, ElemType e){ p = L; int j = 0; while (p \u0026amp;\u0026amp; j \u0026lt; i - 1){ //查找第i-1个节点，p指向该节点 p = p -\u0026gt; next; j++; } if (!p || j \u0026gt; i - 1) return ERROR; s = new LNode; //生成新节点*s s -\u0026gt; data = e; //节点*s数据域指向e s -\u0026gt; next = p -\u0026gt; next; //节点*s的指针域指向节点ai p -\u0026gt; next = s; //节点*p指针域指向节点*s return OK; } 删除 与插入元素一致，但是除了修改 a 的指针域外，还要释放 b 节点所占的空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Status ListDelete(LinkList \u0026amp;L, int i){ //在带头节点的单链表L中，删除第i个元素 p = L; int j = 0; while ((p -\u0026gt; next) \u0026amp;\u0026amp; j \u0026lt; i - 1){ p = p -\u0026gt; next; j++; } if (!(p -\u0026gt; next) || j \u0026gt; i - 1) return EOOER; q = p -\u0026gt; next; //临时保存被删节点的地址以备释放 p -\u0026gt; next = q -\u0026gt; next; //改变删除节点前驱节点的指针域 delete q; return OK; } 单链表应用 线性表合并 1 2 3 4 5 6 7 8 9 void MergeList(List \u0026amp;LA, List LB){ //\u0026amp;LA是引用传递，因为要改变，LB是值传递，因为只用读取 int m = ListLength(LA); int n = ListLength(LB); for (int i = 1; i \u0026lt;= n; i++){ GetElem(LB, i, e); //取LB中第i个数据元素赋给e if (!LocateElem(LA, e)) ListInsert(LA, ++m, e); } } ","date":"2024-11-09T23:42:32+08:00","permalink":"https://mkkkk-create.github.io/2024/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/","title":"单链表及相关操作"},{"content":"Week1 BabyBase 查壳无壳 ida 打开，进入主函数\n发现有个 encode 函数，跟进\n发现是普通的 base64 加密，拿到密文之后用 cyber 解一下即可\n0xGame{N0w_y0u_kn0w_B4se64_Enc0d1ng_w3ll!}\nBinaryMaster 查壳发现无壳，ida 打开，打开之后 F5 反编译就看到 flag 了\n0xGame{114514cc-a3a7-4e36-8db1-5f224b776271}\nSignSign 无壳拖进 ida\n发现这一段很像 flag，尝试找找有没有前面部分的，shift+F12 查看字符串找到前面部分\n0xGame{S1gn1n_h3r3_4nd_b3g1n_Reversing_n0w}\nXor-Beginning 无壳放进 ida，查看主函数\n发现一处异或 解密脚本如下\n1 2 3 4 5 6 7 8 9 10 11 a = [ 126, 53, 11, 42, 39, 44, 51, 31, 118, 55, 27, 114, 49, 30, 54, 12, 76, 68, 99, 114, 87, 73, 8, 69, 66, 1, 90, 4, 19, 76, 0, 0, 0, 21, 100] b = \u0026#39;\u0026#39; for i in range(len(a)): a[i] = a[i] ^ (78 - i) b += chr(a[i]) print(b) 0xGame{X0r_1s_v3ry_Imp0rt4n7!}\nWeek2 BabyUPX 查壳，发现是最简单的 UPX 壳，放进脱壳软件里面脱壳，拖进 ida\n跟进 encode 函数\n发现是位运算，下面填脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 enc = [3, 135, 116, 22, 214, 86, 183, 99, 131, 70, 102, 102, 67, 83, 131, 210, 35, 147, 86, 83, 210, 67, 54, 54, 3, 210, 22, 147, 54, 38, 210, 147, 115, 19, 102, 86, 54, 51, 51, 131, 86, 35, 102, 215] flag = \u0026#39;\u0026#39; for i in range(44): #提取高4位并右移，提取低4位并左移 original = int((enc[i] \u0026amp; 0xF0) / 16) | (enc[i] \u0026amp; 0x0F) \u0026lt;\u0026lt; 4 flag += chr(original) print(flag) #0xGame{68dff458-29e5-4cc0-a9cb-971fec338e2f} (官方 wp 给出) 可以看出每个字节高 4 位和低 4 位交换，实际上就是 16 进制逆序。\nFirstSight-Jar jadx 打开，主要逻辑红框框住，接下来直接上脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def dec(enc): Alphabat = \u0026#34;0123456789abcdef\u0026#34; reverse_map = {} for i in range(len(Alphabat)): new_index = ((i * 5) + 3) % 16 reverse_map[Alphabat[new_index]] = Alphabat[i] dec_str = [] for char in enc: if char in reverse_map: dec_str.append(reverse_map[char]) else: dec_str.append(char) return \u0026#39;\u0026#39;.join(dec_str) enc = \u0026#34;ab50e920-4a97-70d1-b646-cdac5c873376\u0026#34; flag = dec(enc) print(\u0026#34;0xGame{\u0026#34;+ flag + \u0026#34;}\u0026#34;) #0xGame{b8a9fe39-dbe4-4926-87d7-52b5a5140047} FisrtSight-Pyc 看到 pyc 文件，uncompyle6 反编译\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import hashlib user_input = input(\u0026#34;请输入神秘代号：\u0026#34;) if user_input != \u0026#34;Ciallo~\u0026#34;: print(\u0026#34;代号不是这个哦\u0026#34;) exit() input_hash = hashlib.md5(user_input.encode()).hexdigest() input_hash = list(input_hash) for i in range(len(input_hash)): if ord(input_hash[i]) in range(48, 58): original_num = int(input_hash[i]) new_num = (original_num + 5) % 10 input_hash[i] = str(new_num) input_hash = \u0026#34;\u0026#34;.join(input_hash) print(\u0026#34;0xGame{{{}}}\u0026#34;.format(input_hash)) 直接运行一遍，就发现 flag 出来了 0xGame{2f5ef5762bf8a2c043d836b522127e54}\nXor::Ramdom 无壳，拖进 ida 里面，跟进主函数，下图是主要的判断，这题是一道 Windows 下的伪随机数， 记住运行环境不一样随机数生成也会不一样\n我们通过分析可以知道其实这两个随机数种子只会运行 0x77 这一个，因为 v6 的判断只判断了长度，flag 肯定满足长度，下面是一个奇偶性的判断 我们直接写出脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main() { unsigned char ra, key; unsigned char* enc; unsigned long long v13[4]; v13[0] = 0x1221164E1F104F0C; v13[1] = 0x171F240A4B10244B; v13[2] = 0x1A2C5C2108074F09; v13[3] = 99338668810000; srand(0x77); rand(); ra = rand(); enc = (unsigned char*)v13; for (int i = 0; i \u0026lt;= 29; i++){ if (i \u0026amp; 1 != 0) { key = ra; } else key = ra + 3; enc[i] ^= key; } printf(\u0026#34;0xGame{%s}\u0026#34;, enc); return 0; } //0xGame{r4nd0m_i5_n0t_alw4ys_\u0026#39;Random\u0026#39;!} ZzZ 跟进到主函数\n题目给出了字符串的形式 0xGame{%8llx-%4s-%4s-%4s-%12llx} %8x 表示一个以十六进制格式输出的整数，宽度为 8。 %4s 表示一个宽度为 4 的字符串。 %12x 表示一个以十六进制格式输出的整数，宽度为 12。 我们还发现框住的 if 语句有多个条件判断，这时我们可以想到 z3 求解，直接上 z3 库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from z3 import * flag = [] v13 = 0xE544267D v14 = 0xD085A85201A4 v10,v11,v12 = BitVecs(\u0026#34;v10 v11 v12\u0026#34;,32) s = Solver() s.add(11 * v11 + 14 * v10 - v12 == 0x48FB41DDD) s.add(9 * v10 - 3 * v11 + 4 * v12 == 0x2BA692AD7) s.add(((v12 - v11) \u0026gt;\u0026gt; 1) + (v10 ^ 0x87654321) == 3451779756) if s.check()==sat: tmp = s.model() for i in (v10, v11, v12): l = tmp[i].as_long() b = l.to_bytes(4, \u0026#34;little\u0026#34;) flag = b.decode() print(flag) #0xGame{e544267d-7812-44b3-a35d-d085a85201a4} ","date":"2024-10-11T23:42:32+08:00","permalink":"https://mkkkk-create.github.io/2024/0xgame/","title":"0xGame"},{"content":"复现一下久远的比赛哈哈哈\neasypyc 题目直接给了 pyc 文件，我们直接 uncompyle6 反编译\n可以看到图片中显示反汇编失败原因，我们知道这是 python 的字节码，我们用 pycdas 看一下字节码\n找到了报错的原因，接下来我们打开 python 的 opcode 查看到这个指令的代码是 113，转成十六进制就是 0x71, 我们打开 010editor 搜索 71 04 71 06 71 02\n然后删除掉这一段紫色的花指令，当然还没结束，因为 co_code 中有一个 ob_size 成员里面保存了 co_code 的长度，如果 co_code 的实际长度与 ob_size 里记录的长度不匹配的话反编译时依然会报错。接下来就是找到 ob_size 所在的位置将其进行修改，在 python3.8 版本里 ob_size 会以 s 或 t 的类型标志开始接下来的几个字节会是一个整数，代表 co_code 的长度。本题的长度就是上图红框框住的地方，减去 6 个花指令字节改成 62 就可以反编译了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import base64, sys def check(ininput): str1 = \u0026#34;RitdR+kuGPFoYpX4NVP{PVOx[VSzXhLnO{L2Xkj3[l[8\u0026#34; str2 = list(str1) list1 = list(ininput) for q in range(len(str2)): if list1[q] != str2[q]: print(\u0026#34;Wrong!!!\u0026#34;) return return None else: print(\u0026#34;All input is correct!\u0026#34;) def encode(eenv): env = base64.b64encode(eenv.encode(\u0026#34;utf-8\u0026#34;)).decode(\u0026#34;utf-8\u0026#34;) str2 = list(env) for i in range(len(str2)): str2[i] = ord(str2[i]) ^ 2 else: for j in range(11): str2[j] -= 6 else: for k in range(11, 22): str2[k] += 1 else: for h in range(22, 33): str2[h] = str2[h] else: for l in range(33, 44): str2[l] ^= 3 else: for w in range(len(str2)): str2[w] = chr(str2[w]) else: str3 = \u0026#34;\u0026#34; for n in range(len(str2)): str3 += str2[n] else: return str3 enc = input(\u0026#34;Please input your flag:\u0026#34;) ininput = list(enc) if len(ininput) != 33: print(\u0026#34;Wrong length!\u0026#34;) sys.exit() else: env = encode(enc) check(env) 接下来放脚本，一步一步来即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import base64 str1 = \u0026#34;RitdR+kuGPFoYpX4NVP{PVOx[VSzXhLnO{L2Xkj3[l[8\u0026#34; str2 = list(str1) for i in range(len(str2)): str2[i] = ord(str2[i]) for j in range(11): str2[j] += 6 for k in range(11,22): str2[k] -= 1 for h in range(22,33): str2[h] = str2[h] for l in range(33,44): str2[l] ^= 3 for w in range(len(str2)): str2[w] = chr(str2[w]) for m in range(len(str2)): str2[m] = ord(str2[m]) ^ 2 str3 = \u0026#39;\u0026#39; for n in range(len(str2)): str3 += chr(str2[n]) str4 = \u0026#39;\u0026#39; str4 = base64.b64decode(str3).decode(\u0026#39;utf-8\u0026#39;) print(str4) ","date":"2024-09-22T23:42:32+08:00","permalink":"https://mkkkk-create.github.io/2024/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E9%BB%84%E6%B2%B3%E6%B5%81%E5%9F%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B/","title":"第二届黄河流域网络安全技能挑战赛"},{"content":" 本篇博客以 BaseCTF 的 UPX 压缩壳的题目为基础进行讲解 什么是压缩壳 加壳：其实是利用特殊的算法，对 EXE、DLL 文件里的资源进行压缩。类似 WINZIP 的效果，只不过这个压缩之后的文件，可以独立运行，解压过程完全隐蔽，都在内存中完成。解压原理，是加壳工具在文件头里加了一段指令，告诉 CPU，怎么才能解压自己。当加壳时，其实就是给可执行的文件加上个外衣。用户执行的只是这个外壳程序。当执行这个程序的时候这个壳就会把原来的程序在内存中解开，解开后，以后的就交给真正的程序。—- 摘自百度百科\nEasy UPXmini 拿到题目查壳 可以看到写明了被 UPX 壳加密过了，但是这种题通常是出题者为了让大家认识工具出的，所以我们可以直接工具脱壳 这就是脱完壳的结果，后面就是 ida 分析，这里就不细说了\nNormal UPX 查壳 我们发现这个 UPX 壳不能直接工具脱壳，对比上一个 Easy 关卡我们发现红框框住的地方不太一样 这时候我们就引入一个名词：区段名， Normal 关卡中正是修改了 UPX 壳的区段名导致不能直接工具脱壳 接下来我们打开010editor来恢复区段名 恢复区段名后我们就可以工具脱壳了\nNormal UPX PRO 查壳发现不能直接工具脱壳 发现区段名也消失了，试过改区段名发现没用，还是不能脱壳 引入一个新的名词： overlay_offset 这里 overlay_offset 值为 p_info 字段的文件偏移 正确的是 F4 00 00 00，改了之后，就可以正常脱壳了\n手动脱壳 UPX PRO MAX 查壳 我们可以看到入口区段什么都没显示，只有提示被 upx 壳保护，打开 010editor 发现区段名都变成了 00 这个时候我们就搬出更高级的脱壳手法，手动脱壳，本题主要靠 ESP 定律脱壳 (也就是靠堆栈平衡找到 OEP 入口点) 以下是脱壳步骤，首先我们拖入 x64dbg 中，按下 F9 运行 我们看到这里有多个 push，我们前面提到 ESP 就是堆栈平衡，所以我们接下来找到 pop 就可以找到 OEP 入口了 对 RSP 寄存器按下右键 点击在内存窗口中转到\n接着按几次 F9 运行下一断点，可以看到\n上面红色方框中的多个 pop 就说明解压已经结束，正要进入主要函数，下面红色方框中就是 OEP 了，然后我们只需 F8 通过 jmp 跳到正确有效函数的入口\n跳转到这，我们就可以使用插件 scylla 进行脱壳了\n可以看到进程已经填好，OEP 也填好了，我们只要点击 Dump，然后保存好文件 再点击 IAT Autosearch\nIAT 已找到，再点击 Get Imports 最后点击 Fix Dump，选择我们刚才 Dump 下来的文件就可以了。最后分析的时候我们分析的是修复好的文件，UPX PRO MAX_dump_SCY.exe\n","date":"2024-09-20T23:42:32+08:00","permalink":"https://mkkkk-create.github.io/2024/%E4%BB%8E%E5%B7%A5%E5%85%B7%E5%88%B0%E6%89%8B%E5%8A%A8%E5%AD%A6%E4%BC%9A-upx-%E8%84%B1%E5%A3%B3/","title":"从工具到手动学会 UPX 脱壳"},{"content":"编码原理 Base64 编码是将字符串以每 3 个 8 比特 (bit) 的字节子序列拆分成 4 个 6 比特 (bit) 的字节 (6 比特有效字节，其实也是 8 比特的字节，只是最左边两个比特永远为 0) 子序列，再将得到的子序列查找 Base64 的编码索引表，得到对应的字符拼接成新的字符串的一种编码方式。\n举例 （1）. 先将原文转为 ASCII 码 （2）. 将 ASCII 码转为二进制数 （3）. 将二进制数合并，每八个二进制位为一组，将每一组按照索引表对应相应的 base64 码 注：如果编码内容字节数不是 3 的整数倍！！！ 情况1. 如果最后剩下 1 个字节，那么将补 4 个 0 位，编码成 2 个 Base64 字符，然后补两个 \u0026ldquo;=\u0026rdquo; 情况2. 如果最后剩下 2 个字节，那么将补 2 个 0 位，编码成 3 个 Base64 字符，然后补一个 \u0026ldquo;=\u0026rdquo; 在知道了加密原理之后我们就可以逆向解密 先找出编码后的字符在编码之前代表的数字 编码中将 3 位个字符变成 4 个字符，得到这 4 个字符的每个字符代表的原本数字 因为在编码中间每个字符用 base64 码表进行了替换，所以这里要先换回来 在对换回来的数字进行位运算使其还原成 3 个字符 ","date":"2024-09-18T23:42:32+08:00","permalink":"https://mkkkk-create.github.io/2024/base64%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/","title":"Base64算法详解"},{"content":"2024WMCTF Re 复现 Rustdriod 发现是 apk 文件，拖入 jadx 查看 发现加载 wmcheck 的包，apktool 解包打开 so 文件，定位到 check 函数 我们发现这是类似于 rc4 的初始化 之后再次看到函数里面有名称为 rc4 的函数名，我们就可以确定了，但是这个 rc4 是魔改的！！！ 通过其他师傅的 wp(https://blog.wm-team.cn/index.php/archives/80/) 得知是单字节加密，下面是解题脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def KSA(key): S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] return S def PRGA(S): i, j = 0, 0 while True: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] K = S[(S[i] + S[j]) % 256] yield K def RC4(key, text): S = KSA(key) keystream = PRGA(S) res = [] for char in text: res.append(char ^ next(keystream)) return bytes(res) s1=[ 0x77, 0x88, 0x99, 0x66] s2=[0x4E4FCE594215BA1F,0xC745BAE69BFD994,0x87081E9C7F8AFCC0,0x2BB08F87F5646BF5,0x29FF53E2] key=b\u0026#39;fun@eZ\u0026#39; s3=b\u0026#39;\u0026#39;.join(num.to_bytes((num.bit_length()+7)//8, byteorder=\u0026#39;little\u0026#39;) for num in s2) s5=RC4(key,s3) s4=[0]*128 for i in range(len(s5)): s4[i]=s5[i] for i in range(len(s5)): s4[i] ^= s1[i\u0026amp;3] s4[i] = ((s4[i] \u0026lt;\u0026lt; 5) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 3) \u0026amp; 0xff) s4[i] ^= 0xde s4[i] = ((s4[i] \u0026lt;\u0026lt; 4) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 4) \u0026amp; 0xff) s4[i] ^= 0xad s4[i] = ((s4[i] \u0026lt;\u0026lt; 3) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 5) \u0026amp; 0xff) s4[i] ^= 0xbe s4[i] = ((s4[i] \u0026lt;\u0026lt; 2) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 6) \u0026amp; 0xff) s4[i] ^= 0xef s4[i] = ((s4[i] \u0026lt;\u0026lt; 1) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 7) \u0026amp; 0xff) print(chr(s4[i]),end=\u0026#39;\u0026#39;) 得到 flag WMCTF{2a04aed7-e736-43c4-80a7-f6ed28de34eb}\nez_learn 无壳，拖进 ida，反编译之后奇奇怪怪 下个断点调试一下，发现调试就闪退，往下翻看到了 TLS 反调试函数 nop 掉反调试函数，之后发现了一处引起堆栈不平衡的花指令 nop 掉重新编译一下就可以进入主函数了 发现有两个 flag wrong，猜测 flag 应该分成两部分加密 之后发现还有一个加密函数跟进，发现是 SM4 加密 这是 S 盒 对比普通的 SM4 加密，我们发现有魔改，一处异或 0x34，一处 0x12 下面是脚本，基于普通 SM4(https://blog.csdn.net/twq1689739507/article/details/122118411) 修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 #include\u0026lt;stdio.h\u0026gt; #define u8 unsigned char #define u32 unsigned long // S盒 const u8 Sbox[256] = { 0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05, 0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99, 0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62, 0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6, 0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8, 0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35, 0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87, 0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e, 0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1, 0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3, 0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f, 0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51, 0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8, 0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0, 0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84, 0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48 }; // 密钥扩展算法的常数FK const u32 FK[4] = { 0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc }; // 密钥扩展算法的固定参数CK const u32 CK[32] = { 0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279 }; u32 functionB(u32 b); // 查S盒的函数B u32 loopLeft(u32 a, short length); // 循环左移函数 u32 functionL1(u32 a); // 线性变换L u32 functionL2(u32 a); // 线性变换L\u0026#39; u32 functionT(u32 a, short mode); // 合成变换T void extendFirst(u32 MK[], u32 K[]); // 密钥扩展算法第一步 void extendSecond(u32 RK[], u32 K[]); // 密钥扩展算法第二步 void getRK(u32 MK[], u32 K[], u32 RK[]); // 轮密钥获取算法 void iterate32(u32 X[], u32 RK[]); // 迭代算法 void reverse(u32 X[], u32 Y[]); // 反转函数 void encryptSM4(u32 X[], u32 RK[], u32 Y[]); // 加密算法 void decryptSM4(u32 X[], u32 RK[], u32 Y[]); // 解密算法 /* 查S盒的函数B 参数: u32 b 返回值: 查S盒的结果u32 b */ u32 functionB(u32 b) { u8 a[4]; short i; a[0] = b / 0x1000000; a[1] = b / 0x10000; a[2] = b / 0x100; a[3] = b; b = Sbox[a[0]] * 0x1000000 + Sbox[a[1]] * 0x10000 + Sbox[a[2]] * 0x100 + Sbox[a[3]]; return b; } /* 循环左移算法 参数： u32 a length：循环左移位数 返回值：u32 b */ u32 loopLeft(u32 a, short length) { short i; for (i = 0; i \u0026lt; length; i++) { a = a * 2 + a / 0x80000000; } return a; } /* 密钥线性变换函数L 参数： u32 a 返回值：线性变换后的u32 a */ u32 functionL1(u32 a) { return a ^ loopLeft(a, 2) ^ loopLeft(a, 10) ^ loopLeft(a, 18) ^ loopLeft(a, 24); } /* 密钥线性变换函数L\u0026#39; 参数： u32 a 返回值：移位操作后的u32 a */ u32 functionL2(u32 a) { return a ^ loopLeft(a, 13) ^ loopLeft(a, 23); } /* 合成变换T 参数： u32 a short mode：1表示明文的T，调用L；2表示密钥的T，调用L\u0026#39; 返回值：合成变换后的u32 a */ u32 functionT(u32 a, short mode) { return mode == 1 ? functionL1(functionB(a)) : functionL2(functionB(a)); } /* 密钥扩展算法第一步 参数： MK[4]：密钥 K[4]:中间数据，保存结果 （FK[4]：常数） 返回值：无 */ void extendFirst(u32 MK[], u32 K[]) { int i; for (i = 0; i \u0026lt; 4; i++) { K[i] = MK[i] ^ FK[i]^0x34343434; } } void extendThird(u32 MK[], u32 K[]) { int i; for (i = 0; i \u0026lt; 1; i++) { K[i+1] = MK[i] ^ K[i] ^ 0x34343434; } } /* 密钥扩展算法第二步 参数： RK[32]：轮密钥，保存结果 K[4]：中间数据 （CK[32]：固定参数） 返回值：无 */ void extendSecond(u32 RK[], u32 K[]) { short i; for (i = 0; i \u0026lt; 32; i++) { K[(i + 4) % 4] = 0x34343434^K[i % 4] ^ functionT(K[(i + 1) % 4] ^ K[(i + 2) % 4] ^ K[(i + 3) % 4] ^ CK[i]^0x12121212, 2); RK[i] = K[(i + 4) % 4]; } } /* 密钥扩展算法 参数： MK[4]：密钥 K[4]：中间数据 RK[32]：轮密钥，保存结果 返回值：无 */ void getRK(u32 MK[], u32 K[], u32 RK[]) { extendFirst(MK, K); extendSecond(RK, K); //extendThird(MK,K); } /* 迭代32次 参数： u32 X[4]：迭代对象，保存结果 u32 RK[32]：轮密钥 返回值：无 */ void iterate32(u32 X[], u32 RK[]) { short i; for (i = 0; i \u0026lt; 32; i++) { X[(i + 4) % 4] = X[i % 4] ^0x34343434^ functionT(X[(i + 1) % 4] ^ X[(i + 2) % 4] ^ X[(i + 3) % 4] ^ RK[i]^0x12121212, 1); } } /* 反转函数 参数； u32 X[4]：反转对象 u32 Y[4]：反转结果 返回值：无 */ void reverse(u32 X[], u32 Y[]) { short i; for (i = 0; i \u0026lt; 4; i++) { Y[i] = X[4 - 1 - i]; } } /* 加密算法 参数： u32 X[4]：明文 u32 RK[32]：轮密钥 u32 Y[4]：密文，保存结果 返回值：无 */ void encryptSM4(u32 X[], u32 RK[], u32 Y[]) { iterate32(X, RK); reverse(X, Y); } /* 解密算法 参数： u32 X[4]：密文 u32 RK[32]：轮密钥 u32 Y[4]：明文，保存结果 返回值：无 */ void decryptSM4(u32 X[], u32 RK[], u32 Y[]) { short i; u32 reverseRK[32]; for (i = 0; i \u0026lt; 32; i++) { reverseRK[i] = RK[32 - 1 - i]; } iterate32(X, reverseRK); reverse(X, Y); } int main(void) { u32 X[4]; // 明文 u32 MK[4] = { 0x22313 ,0x821DEF ,0x123128 ,0x43434310 }; // 密钥 u32 RK[32]; // 轮密钥 u32 K[4]; // 中间数据 u32 Y[4] = { 0xC676E86F, 0xAD67E8F8, 0xCA9DB9AC, 0xB1AE068E }; // 密文 //u32 Y[4] = { 0xD51B0298, 0xD827C6D3, 0x31A5A335, 0x893A7A66 }; short i; // 临时变量 decryptSM4(Y, RK, X); printf(\u0026#34;%08x %08x %08x %08x\\n\u0026#34;, X[0], X[1], X[2], X[3]); return 0; } 得到flag：WMCTF{CRC32andAnti_IS_SO_EASY!!}\nre1 拖入 jadx 查看主函数，发现加载 Encrypt 的 so 文件中的 checkyourflag 函数，解包 apk，so 拖入 ida 下断点调试不了，后面看官方 wp 才知道是因为动态注册的原因 JNI 注册方法分为静态注册和动态注册，静态注册的方法可以在 IDA 的函数窗口或者导出表中直接找到，比较简单。动态注册的方法需要分析 JNI_OnLoad 函数 ","date":"2024-09-11T23:42:32+08:00","permalink":"https://mkkkk-create.github.io/2024/wmctf/","title":"WMCTF"}]
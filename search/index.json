[{"content":"编码原理 Base64编码是将字符串以每3个8比特(bit)的字节子序列拆分成4个6比特(bit)的字节(6比特有效字节，其实也是8比特的字节，只是最左边两个比特永远为0)子序列，再将得到的子序列查找Base64的编码索引表，得到对应的字符拼接成新的字符串的一种编码方式。\n举例 图摘自知乎\r（1）.先将原文转为ASCII码\n（2）.将ASCII码转为二进制数\n（3）.将二进制数合并，每八个二进制位为一组，将每一组按照索引表对应相应的base64码\n注：如果编码内容字节数不是3的整数倍！！！ 1.如果最后剩下1个字节，那么将补 4个 0 位，编码成 2个 Base64 字符，然后补两个\u0026quot;=\u0026quot; 图摘自知乎\r2.如果最后剩下 2 个字节，那么将补 2 个 0 位，编码成 3 个 Base64 字符，然后补一个\u0026quot;=\u0026quot; 图摘自知乎\r在知道了加密原理之后我们就可以逆向解密\n先找出编码后的字符在编码之前代表的数字\n编码中将3位个字符变成4个字符，得到这4个字符的每个字符代表的原本数字\n因为在编码中间每个字符用base64码表进行了替换，所以这里要先换回来\n在对换回来的数字进行位运算使其还原成3个字符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // Base64字符表 static const char base64_chars[] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; // 将Base64字符转换为其对应的整数值 int base64_value(char c) { int i; for (i = 0; i \u0026lt; 64; i++) { if (base64_chars[i] == c) { return i; } } return -1; } // 将Base64字符串解码为原始数据 void base64_decode(const char *input, unsigned char *output, int output_size) { int input_size = strlen(input); int i, j, k; unsigned char temp[4]; for (i = 0, j = 0; i \u0026lt; input_size; i += 4) { for (k = 0; k \u0026lt; 4; k++) { temp[k] = base64_value(input[i + k]); } output[j++] = (temp[0] \u0026lt;\u0026lt; 2) | (temp[1] \u0026gt;\u0026gt; 4); if (k \u0026gt;= 2) { output[j++] = ((temp[1] \u0026amp; 0x0F) \u0026lt;\u0026lt; 4) | (temp[2] \u0026gt;\u0026gt; 2); } if (k \u0026gt;= 3) { output[j++] = ((temp[2] \u0026amp; 0x03) \u0026lt;\u0026lt; 6) | temp[3]; } } output[j] = \u0026#39;\\0\u0026#39;; } int main() { const char *input = \u0026#34;SGVsbG8sIFdvcmxkIQ==\u0026#34;; // \u0026#34;Hello, World!\u0026#34;的Base64编码 unsigned char output[strlen(input)]; base64_encode() base64_decode(input, output, sizeof(output)); printf(\u0026#34;Decoded string: %s\u0026#34;, output); return 0; } ","date":"2024-09-18T00:57:35+08:00","permalink":"https://mkkkk-create.github.io/2024/base64%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/","title":"Base64算法详解"},{"content":"2024WMCTF Re复现 Rustdriod 发现是apk文件，拖入jadx查看 发现加载wmcheck的包，apktool解包打开so文件，定位到check函数 我们发现这是类似于rc4的初始化 之后再次看到函数里面有名称为rc4的函数名，我们就可以确定了，但是这个rc4是魔改的！！！ 通过其他师傅的wp(https://blog.wm-team.cn/index.php/archives/80/)得知是单字节加密，下面是解题脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def KSA(key): S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] return S def PRGA(S): i, j = 0, 0 while True: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] K = S[(S[i] + S[j]) % 256] yield K def RC4(key, text): S = KSA(key) keystream = PRGA(S) res = [] for char in text: res.append(char ^ next(keystream)) return bytes(res) s1=[ 0x77, 0x88, 0x99, 0x66] s2=[0x4E4FCE594215BA1F,0xC745BAE69BFD994,0x87081E9C7F8AFCC0,0x2BB08F87F5646BF5,0x29FF53E2] key=b\u0026#39;fun@eZ\u0026#39; s3=b\u0026#39;\u0026#39;.join(num.to_bytes((num.bit_length()+7)//8, byteorder=\u0026#39;little\u0026#39;) for num in s2) s5=RC4(key,s3) s4=[0]*128 for i in range(len(s5)): s4[i]=s5[i] for i in range(len(s5)): s4[i] ^= s1[i\u0026amp;3] s4[i] = ((s4[i] \u0026lt;\u0026lt; 5) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 3) \u0026amp; 0xff) s4[i] ^= 0xde s4[i] = ((s4[i] \u0026lt;\u0026lt; 4) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 4) \u0026amp; 0xff) s4[i] ^= 0xad s4[i] = ((s4[i] \u0026lt;\u0026lt; 3) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 5) \u0026amp; 0xff) s4[i] ^= 0xbe s4[i] = ((s4[i] \u0026lt;\u0026lt; 2) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 6) \u0026amp; 0xff) s4[i] ^= 0xef s4[i] = ((s4[i] \u0026lt;\u0026lt; 1) \u0026amp; 0xff) | ((s4[i] \u0026gt;\u0026gt; 7) \u0026amp; 0xff) print(chr(s4[i]),end=\u0026#39;\u0026#39;) 得到flag WMCTF{2a04aed7-e736-43c4-80a7-f6ed28de34eb}\nez_learn 无壳，拖进ida，反编译之后奇奇怪怪 下个断点调试一下，发现调试就闪退，往下翻看到了TLS反调试函数 nop掉反调试函数，之后发现了一处引起堆栈不平衡的花指令 nop掉重新编译一下就可以进入主函数了 发现有两个flag wrong，猜测flag应该分成两部分加密 之后发现还有一个加密函数跟进，发现是SM4加密 这是S盒 对比普通的SM4加密，我们发现有魔改，一处异或0x34，一处0x12 下面是脚本，基于普通SM4(https://blog.csdn.net/twq1689739507/article/details/122118411)修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 #include\u0026lt;stdio.h\u0026gt; #define u8 unsigned char #define u32 unsigned long // S盒 const u8 Sbox[256] = { 0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05, 0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99, 0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62, 0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6, 0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8, 0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35, 0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87, 0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e, 0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1, 0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3, 0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f, 0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51, 0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8, 0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0, 0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84, 0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48 }; // 密钥扩展算法的常数FK const u32 FK[4] = { 0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc }; // 密钥扩展算法的固定参数CK const u32 CK[32] = { 0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279 }; u32 functionB(u32 b); // 查S盒的函数B u32 loopLeft(u32 a, short length); // 循环左移函数 u32 functionL1(u32 a); // 线性变换L u32 functionL2(u32 a); // 线性变换L\u0026#39; u32 functionT(u32 a, short mode); // 合成变换T void extendFirst(u32 MK[], u32 K[]); // 密钥扩展算法第一步 void extendSecond(u32 RK[], u32 K[]); // 密钥扩展算法第二步 void getRK(u32 MK[], u32 K[], u32 RK[]); // 轮密钥获取算法 void iterate32(u32 X[], u32 RK[]); // 迭代算法 void reverse(u32 X[], u32 Y[]); // 反转函数 void encryptSM4(u32 X[], u32 RK[], u32 Y[]); // 加密算法 void decryptSM4(u32 X[], u32 RK[], u32 Y[]); // 解密算法 /* 查S盒的函数B 参数: u32 b 返回值: 查S盒的结果u32 b */ u32 functionB(u32 b) { u8 a[4]; short i; a[0] = b / 0x1000000; a[1] = b / 0x10000; a[2] = b / 0x100; a[3] = b; b = Sbox[a[0]] * 0x1000000 + Sbox[a[1]] * 0x10000 + Sbox[a[2]] * 0x100 + Sbox[a[3]]; return b; } /* 循环左移算法 参数： u32 a length：循环左移位数 返回值：u32 b */ u32 loopLeft(u32 a, short length) { short i; for (i = 0; i \u0026lt; length; i++) { a = a * 2 + a / 0x80000000; } return a; } /* 密钥线性变换函数L 参数： u32 a 返回值：线性变换后的u32 a */ u32 functionL1(u32 a) { return a ^ loopLeft(a, 2) ^ loopLeft(a, 10) ^ loopLeft(a, 18) ^ loopLeft(a, 24); } /* 密钥线性变换函数L\u0026#39; 参数： u32 a 返回值：移位操作后的u32 a */ u32 functionL2(u32 a) { return a ^ loopLeft(a, 13) ^ loopLeft(a, 23); } /* 合成变换T 参数： u32 a short mode：1表示明文的T，调用L；2表示密钥的T，调用L\u0026#39; 返回值：合成变换后的u32 a */ u32 functionT(u32 a, short mode) { return mode == 1 ? functionL1(functionB(a)) : functionL2(functionB(a)); } /* 密钥扩展算法第一步 参数： MK[4]：密钥 K[4]:中间数据，保存结果 （FK[4]：常数） 返回值：无 */ void extendFirst(u32 MK[], u32 K[]) { int i; for (i = 0; i \u0026lt; 4; i++) { K[i] = MK[i] ^ FK[i]^0x34343434; } } void extendThird(u32 MK[], u32 K[]) { int i; for (i = 0; i \u0026lt; 1; i++) { K[i+1] = MK[i] ^ K[i] ^ 0x34343434; } } /* 密钥扩展算法第二步 参数： RK[32]：轮密钥，保存结果 K[4]：中间数据 （CK[32]：固定参数） 返回值：无 */ void extendSecond(u32 RK[], u32 K[]) { short i; for (i = 0; i \u0026lt; 32; i++) { K[(i + 4) % 4] = 0x34343434^K[i % 4] ^ functionT(K[(i + 1) % 4] ^ K[(i + 2) % 4] ^ K[(i + 3) % 4] ^ CK[i]^0x12121212, 2); RK[i] = K[(i + 4) % 4]; } } /* 密钥扩展算法 参数： MK[4]：密钥 K[4]：中间数据 RK[32]：轮密钥，保存结果 返回值：无 */ void getRK(u32 MK[], u32 K[], u32 RK[]) { extendFirst(MK, K); extendSecond(RK, K); //extendThird(MK,K); } /* 迭代32次 参数： u32 X[4]：迭代对象，保存结果 u32 RK[32]：轮密钥 返回值：无 */ void iterate32(u32 X[], u32 RK[]) { short i; for (i = 0; i \u0026lt; 32; i++) { X[(i + 4) % 4] = X[i % 4] ^0x34343434^ functionT(X[(i + 1) % 4] ^ X[(i + 2) % 4] ^ X[(i + 3) % 4] ^ RK[i]^0x12121212, 1); } } /* 反转函数 参数； u32 X[4]：反转对象 u32 Y[4]：反转结果 返回值：无 */ void reverse(u32 X[], u32 Y[]) { short i; for (i = 0; i \u0026lt; 4; i++) { Y[i] = X[4 - 1 - i]; } } /* 加密算法 参数： u32 X[4]：明文 u32 RK[32]：轮密钥 u32 Y[4]：密文，保存结果 返回值：无 */ void encryptSM4(u32 X[], u32 RK[], u32 Y[]) { iterate32(X, RK); reverse(X, Y); } /* 解密算法 参数： u32 X[4]：密文 u32 RK[32]：轮密钥 u32 Y[4]：明文，保存结果 返回值：无 */ void decryptSM4(u32 X[], u32 RK[], u32 Y[]) { short i; u32 reverseRK[32]; for (i = 0; i \u0026lt; 32; i++) { reverseRK[i] = RK[32 - 1 - i]; } iterate32(X, reverseRK); reverse(X, Y); } int main(void) { u32 X[4]; // 明文 u32 MK[4] = { 0x22313 ,0x821DEF ,0x123128 ,0x43434310 }; // 密钥 u32 RK[32]; // 轮密钥 u32 K[4]; // 中间数据 u32 Y[4] = { 0xC676E86F, 0xAD67E8F8, 0xCA9DB9AC, 0xB1AE068E }; // 密文 //u32 Y[4] = { 0xD51B0298, 0xD827C6D3, 0x31A5A335, 0x893A7A66 }; short i; // 临时变量 decryptSM4(Y, RK, X); printf(\u0026#34;%08x %08x %08x %08x\\n\u0026#34;, X[0], X[1], X[2], X[3]); return 0; } flag：WMCTF{CRC32andAnti_IS_SO_EASY!!}\nre1 拖入jadx查看主函数，发现加载Encrypt的so文件中的checkyourflag函数，解包apk，so拖入ida 下断点调试不了，后面看官方wp才知道是因为动态注册的原因 JNI注册方法分为静态注册和动态注册，静态注册的方法可以在IDA的函数窗口或者导出表中直接找到，比较简单。动态注册的方法需要分析JNI_OnLoad函数 从图片可以得知题目使用bytehook直接把几个函数hook了 接下来回到真正的check函数处，看到了被hook的函数，接下来就可以下断点慢慢调试了 经过分析，我们可以知道这是一个普通的xtea+魔改，异或了0x5A 下面是脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from ctypes import * def decrypt(v, key): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) delta = 0x5EEFEF3 total = c_uint32(0 - (delta * 66)) for i in range(66): v1.value -= (((v0.value \u0026lt;\u0026lt; 6) ^ (v0.value \u0026gt;\u0026gt; 6)) + v0.value) ^ (total.value + key[((total.value \u0026amp; 0xff) \u0026gt;\u0026gt; 6)]) total.value += delta v0.value -= (((v1.value \u0026lt;\u0026lt; 6) ^ (v1.value \u0026gt;\u0026gt; 6)) + v1.value) ^ (total.value + key[total.value \u0026amp; 3]) return v0.value, v1.value def xtea(inp: bytes, key: bytes): from struct import pack, unpack k = unpack(\u0026#34;\u0026lt;4I\u0026#34;, key) inp_len = len(inp) // 4 value = unpack(f\u0026#34;\u0026lt;{inp_len}I\u0026#34;, inp) res = b\u0026#34;\u0026#34; for i in range(0, inp_len, 2): v = [value[i], value[i + 1]] # x = encrypt(v,k) x = decrypt(v, k) res += pack(\u0026#34;\u0026lt;2I\u0026#34;, *x) return res cip = bytes([0xD2, 0x5F, 0xC0, 0xEF, 0x5E, 0x62, 0x78, 0x93, 0xA0, 0x41, 0x1F, 0x84, 0x4A, 0x5F, 0xD0, 0x06, 0x9A, 0x8F, 0x89, 0xDC, 0xFC, 0x7C, 0xAA, 0x21, 0x0B, 0xFB, 0x29, 0x42, 0x8B, 0x2B, 0xE5, 0x31]) key = bytes([0xFF, 0xFF, 0xFF, 0xFF, 0xAA, 0xAA, 0xAA, 0xAA, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11]) ret = xtea(cip, key) ret = bytearray(ret) for i in range(len(ret)): ret[i] ^= i ^ 0x5a print(bytes(ret)) ","date":"2024-09-11T07:37:15+08:00","permalink":"https://mkkkk-create.github.io/2024/wmctf/","title":"WMCTF"}]